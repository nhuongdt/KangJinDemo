// knockout-jqautocomplete 0.4.4 | (c) 2016 Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license
; (function (factory) {
    if (typeof define === "function" && define.amd) {
        // AMD anonymous module
        define(["knockout", "jquery", "jquery-ui/autocomplete"], factory);
    } else {
        // No module loader - put directly in global namespace
        factory(window.ko, jQuery);
    }
})(function (ko, $) {
    var JqAutoHangHoa = function () {
        var self = this,
            unwrap = ko.utils.unwrapObservable; //support older KO versions that did not have ko.unwrap

        //binding's init function
        this.init = function (element, valueAccessor, allBindings, data, context) {
            var existingSelect, existingChange,
                options = unwrap(valueAccessor()),
                config = {},
                filter = typeof options.filter === "function" ? options.filter : self.defaultFilter;

            //extend with global options
            ko.utils.extend(config, self.options);
            //override with options passed in binding
            ko.utils.extend(config, options.options);

            //get source from a function (can be remote call)
            if (typeof options.source === "function" && !ko.isObservable(options.source)) {
                config.source = function (request, response) {
                    //provide a wrapper to the normal response callback
                    var callback = function (data) {
                        self.processOptions(valueAccessor, null, data, request, response);
                    };

                    //call the provided function for retrieving data
                    options.source.call(context.$data, request.term, callback);
                };
            }
            else {
                //process local data
                config.source = self.processOptions.bind(self, valueAccessor, filter, options.source);
            }

            //save any passed in select/change calls
            existingSelect = typeof config.select === "function" && config.select;
            existingChange = typeof config.change === "function" && config.change;

            //handle updating the actual value
            config.select = function (event, ui) {
                if (ui.item && ui.item.actual) {
                    options.value(ui.item.actual);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        console.log("writeable")
                        options.dataValue(ui.item.data);
                    }
                }

                if (existingSelect) {
                    existingSelect.apply(this, arguments);
                }
                $(this).select();
                //vmXuatHuy.SelectedHHEnterkey(); // giọi hàm selected từ js xuất hủy
                itemSelected(ui.item.data); // lấy item
            };

            //user made a change without selecting a value from the list
            config.change = function (event, ui) {
                if (!ui.item || !ui.item.actual) {
                    options.value(event.target && event.target.value);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(null);
                    }
                }

                if (existingChange) {
                    existingChange.apply(this, arguments);
                }
            };

            //initialize the widget
            var widget = $(element).autocomplete(config).data("ui-autocomplete");

            //render a template for the items
            if (options.template) {
                widget._renderItem = self.renderItem.bind(self, options.template, context);
            }

            //destroy the widget if KO removes the element
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                if (widget && typeof widget.destroy === "function") {
                    widget.destroy();
                    widget = null;
                }
            });
        };

        //the binding's update function. keep value in sync with model
        this.update = function (element, valueAccessor) {
            var propNames, sources,
                options = unwrap(valueAccessor()),
                value = unwrap(options && options.value);

            if (!value && value !== 0) {
                value = "";
            }

            // find the appropriate value for the input
            sources = unwrap(options.source);
            propNames = self.getPropertyNames(valueAccessor);

            // if there is local data, then try to determine the appropriate value for the input
            if ($.isArray(sources) && propNames.value) {
                value = ko.utils.arrayFirst(sources, function (opt) {
                    return opt[propNames.value] == value;
                }
                ) || value;
            }

            if (propNames.input && value && typeof value === "object") {
                element.value = value[propNames.input];
            }
            else {
                element.value = value;
            }
        };

        //if dealing with local data, the default filtering function
        this.defaultFilter = function (item, term) {
            term = term && term.toLowerCase();
            return (item || item === 0) && ko.toJSON(item).toLowerCase().indexOf(term) > -1;
        };
        var _IDchinhanh = $('#hd_IDdDonVi').val(); // lấy ID chi nhánh
        var _ID_NguoiDung = $('.idnguoidung').text();
        var timer = null;
        this.processOptions = function (valueAccessor, filter, data, request, response) {
            //console.log("abc");
            clearTimeout(timer);
            var propname = this.getPropertyNames(valueAccessor);
            timer = setTimeout(function () {
                ajaxHelper("/api/DanhMuc/BH_XuatHuyAPI/" + "getListHangHoa_TonKho?maHH=" + request.term + "&ID_ChiNhanh=" + _IDchinhanh + "&ID_NguoiDung=" + _ID_NguoiDung, 'GET').done(function (data) {
                    response(data);
                });
            }, 200);
        };

        this.select = function (event, ui) {
            $(this).val(ui.item.value).change();
        }

        //if specified, use a template to render an item
        this.renderItem = function (templateName, context, ul, item) {
            var $li = $("<li></li>").appendTo(ul),
                itemContext = context.createChildContext(item.data);

            //apply the template binding
            ko.applyBindingsToNode($li[0], { template: templateName }, itemContext);

            //clean up
            $li.one("remove", ko.cleanNode.bind(ko, $li[0]));

            return $li;
        };

        //retrieve the property names to use for the label, input, and value
        this.getPropertyNames = function (valueAccessor) {
            var options = ko.toJS(valueAccessor());

            return {
                label: options.labelProp || options.valueProp,
                input: options.inputProp || options.labelProp || options.valueProp,
                value: options.valueProp
            };
        };

        //default global options passed into autocomplete widget
        this.options = {
            autoFocus: true,
            delay: 50,
        };
    };

    ko.bindingHandlers.JqAutoHangHoa = new JqAutoHangHoa();
    var JqAutoHangHoa_LoHang = function () {
        var self = this,
            unwrap = ko.utils.unwrapObservable; //support older KO versions that did not have ko.unwrap

        //binding's init function
        this.init = function (element, valueAccessor, allBindings, data, context) {
            var existingSelect, existingChange,
                options = unwrap(valueAccessor()),
                config = {},
                filter = typeof options.filter === "function" ? options.filter : self.defaultFilter;

            //extend with global options
            ko.utils.extend(config, self.options);
            //override with options passed in binding
            ko.utils.extend(config, options.options);

            //get source from a function (can be remote call)
            if (typeof options.source === "function" && !ko.isObservable(options.source)) {
                config.source = function (request, response) {
                    //provide a wrapper to the normal response callback
                    var callback = function (data) {
                        self.processOptions(valueAccessor, null, data, request, response);
                    };

                    //call the provided function for retrieving data
                    options.source.call(context.$data, request.term, callback);
                };
            }
            else {
                //process local data
                config.source = self.processOptions.bind(self, valueAccessor, filter, options.source);
            }

            //save any passed in select/change calls
            existingSelect = typeof config.select === "function" && config.select;
            existingChange = typeof config.change === "function" && config.change;
           
            //handle updating the actual value
            config.select = function (event, ui) {
                if (ui.item && ui.item.actual) {
                    options.value(ui.item.actual);
                  
                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(ui.item.data);
                    }
                }

                if (existingSelect) {
                    existingSelect.apply(this, arguments);
                }
                $(this).select();
                // giọi hàm selected từ js xuất hủy
                //console.log($(this).select());
                itemSelected_LoHang(ui.item.data);
            };

            //user made a change without selecting a value from the list
            config.change = function (event, ui) {
                if (!ui.item || !ui.item.actual) {
                    options.value(event.target && event.target.value);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(null);
                    }
                }

                if (existingChange) {
                    existingChange.apply(this, arguments);
                }
            };

            //initialize the widget
            var widget = $(element).autocomplete(config).data("ui-autocomplete");

            //render a template for the items
            if (options.template) {
                widget._renderItem = self.renderItem.bind(self, options.template, context);
            }

            //destroy the widget if KO removes the element
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                if (widget && typeof widget.destroy === "function") {
                    widget.destroy();
                    widget = null;
                }
            });
        };

        //the binding's update function. keep value in sync with model
        this.update = function (element, valueAccessor) {
            var propNames, sources,
                options = unwrap(valueAccessor()),
                value = unwrap(options && options.value);

            if (!value && value !== 0) {
                value = "";
            }

            // find the appropriate value for the input
            sources = unwrap(options.source);
            propNames = self.getPropertyNames(valueAccessor);

            // if there is local data, then try to determine the appropriate value for the input
            if ($.isArray(sources) && propNames.value) {
                value = ko.utils.arrayFirst(sources, function (opt) {
                    return opt[propNames.value] == value;
                }
                ) || value;
            }

            if (propNames.input && value && typeof value === "object") {
                element.value = value[propNames.input];
            }
            else {
                element.value = value;
            }
        };

        //if dealing with local data, the default filtering function
        this.defaultFilter = function (item, term) {
            term = term && term.toLowerCase();
            return (item || item === 0) && ko.toJSON(item).toLowerCase().indexOf(term) > -1;
        };
        var _IDchinhanh = $('#hd_IDdDonVi').val(); // lấy ID chi nhánh
        var _ID_NguoiDung = $('.idnguoidung').text(); // lấy id người dùng
        var timer = null;
        this.processOptions = function (valueAccessor, filter, data, request, response) {
            //console.log("abc");
            clearTimeout(timer);
            var propname = this.getPropertyNames(valueAccessor);
            timer = setTimeout(function () {
                ajaxHelper("/api/DanhMuc/BH_XuatHuyAPI/" + "getListHangHoaLoHang_TonKho?maHH=" + request.term + "&ID_ChiNhanh=" + _IDchinhanh + "&ID_NguoiDung=" + _ID_NguoiDung, 'GET').done(function (data) {
                    response(data);
                });
            }, 200);
        };

        this.select = function (event, ui) {
            $(this).val(ui.item.value).change();
        }

        //if specified, use a template to render an item
        this.renderItem = function (templateName, context, ul, item) {
            var $li = $("<li></li>").appendTo(ul),
                itemContext = context.createChildContext(item.data);

            //apply the template binding
            ko.applyBindingsToNode($li[0], { template: templateName }, itemContext);

            //clean up
            $li.one("remove", ko.cleanNode.bind(ko, $li[0]));

            return $li;
        };

        //retrieve the property names to use for the label, input, and value
        this.getPropertyNames = function (valueAccessor) {
            var options = ko.toJS(valueAccessor());

            return {
                label: options.labelProp || options.valueProp,
                input: options.inputProp || options.labelProp || options.valueProp,
                value: options.valueProp
            };
        };

        //default global options passed into autocomplete widget
        this.options = {
            autoFocus: true,
            delay: 50,
        };
    };

    ko.bindingHandlers.JqAutoHangHoa_LoHang = new JqAutoHangHoa_LoHang();
    //JQAUTO gốc
    var JqAuto = function () {
        var self = this,
            unwrap = ko.utils.unwrapObservable; //support older KO versions that did not have ko.unwrap

        //binding's init function
        this.init = function (element, valueAccessor, allBindings, data, context) {
            var existingSelect, existingChange,
                options = unwrap(valueAccessor()),
                config = {},
                filter = typeof options.filter === "function" ? options.filter : self.defaultFilter;

            //extend with global options
            ko.utils.extend(config, self.options);
            //override with options passed in binding
            ko.utils.extend(config, options.options);

            //get source from a function (can be remote call)
            if (typeof options.source === "function" && !ko.isObservable(options.source)) {
                config.source = function (request, response) {
                    //provide a wrapper to the normal response callback
                    var callback = function (data) {
                        self.processOptions(valueAccessor, null, data, request, response);
                    };

                    //call the provided function for retrieving data
                    options.source.call(context.$data, request.term, callback);
                };
            }
            else {
                //process local data
                config.source = self.processOptions.bind(self, valueAccessor, filter, options.source);
            }

            //save any passed in select/change calls
            existingSelect = typeof config.select === "function" && config.select;
            existingChange = typeof config.change === "function" && config.change;

            //handle updating the actual value
            config.select = function (event, ui) {
             
                if (ui.item && ui.item.actual) {
                    options.value(ui.item.actual);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        console.log("writeable")
                        options.dataValue(ui.item.data);
                    }
                }

                if (existingSelect) {
                    existingSelect.apply(this, arguments);
                }
                $(this).select();
            };

            //user made a change without selecting a value from the list
            config.change = function (event, ui) {
               
                if (!ui.item || !ui.item.actual) {
                    options.value(event.target && event.target.value);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(null);
                    }
                }

                if (existingChange) {
                    existingChange.apply(this, arguments);
                }
            };

            //initialize the widget
            var widget = $(element).autocomplete(config).data("ui-autocomplete");

            //render a template for the items
            if (options.template) {
                widget._renderItem = self.renderItem.bind(self, options.template, context);
            }

            //destroy the widget if KO removes the element
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                if (widget && typeof widget.destroy === "function") {
                    widget.destroy();
                    widget = null;
                }
            });
        };

        //the binding's update function. keep value in sync with model
        this.update = function (element, valueAccessor) {
            var propNames, sources,
                options = unwrap(valueAccessor()),
                value = unwrap(options && options.value);

            if (!value && value !== 0) {
                value = "";
            }

            // find the appropriate value for the input
            sources = unwrap(options.source);
            propNames = self.getPropertyNames(valueAccessor);

            // if there is local data, then try to determine the appropriate value for the input
            if ($.isArray(sources) && propNames.value) {
                value = ko.utils.arrayFirst(sources, function (opt) {
                    return opt[propNames.value] == value;
                }
                ) || value;
            }

            if (propNames.input && value && typeof value === "object") {
                element.value = value[propNames.input];
            }
            else {
                element.value = value;
            }
        };
        //if dealing with local data, the default filtering function
        this.defaultFilter = function (item, term) {
            term = term && term.toLowerCase();
            return (item || item === 0) && ko.toJSON(item).toLowerCase().indexOf(term) > -1;
        };

        var timer = null;
        this.processOptions = function (valueAccessor, filter, data, request, response) {
            clearTimeout(timer);
            var propname = this.getPropertyNames(valueAccessor);
            timer = setTimeout(function () {
                var item, index, length,
                    items = unwrap(data) || [],
                    results = [],
                    props = propname;

                //filter/map items
                for (index = 0, length = items.length; index < length; index++) {
                    item = items[index];
                    if (!filter || filter(item, request.term)) {
                        results.push({
                            label: props.label ? item[props.label] : item.toString(),
                            value: props.input ? item[props.input] : item.toString(),
                            actual: props.value ? item[props.value] : item,
                            data: item
                        });
                    }
                    if (results.length >= 30) {
                        break;
                    }
                }
                //call autocomplete callback to display list
                response(results);
            }, 150);
        };

        this.select = function (event, ui) {
            console.log("click1");
            $(this).val(ui.item.value).change();
        }

        //if specified, use a template to render an item
        this.renderItem = function (templateName, context, ul, item) {
            var $li = $("<li></li>").appendTo(ul),
                itemContext = context.createChildContext(item.data);

            //apply the template binding
            ko.applyBindingsToNode($li[0], { template: templateName }, itemContext);

            //clean up
            $li.one("remove", ko.cleanNode.bind(ko, $li[0]));

            return $li;
        };

        //retrieve the property names to use for the label, input, and value
        this.getPropertyNames = function (valueAccessor) {
            var options = ko.toJS(valueAccessor());

            return {
                label: options.labelProp || options.valueProp,
                input: options.inputProp || options.labelProp || options.valueProp,
                value: options.valueProp
            };
        };

        //default global options passed into autocomplete widget
        this.options = {
            autoFocus: true,
            delay: 50,
        };
    };

    ko.bindingHandlers.jqAuto = new JqAuto();
    //Select hàng hóa nhập hàng
    var JqAutoHHNH = function () {
        var self = this,
            unwrap = ko.utils.unwrapObservable; //support older KO versions that did not have ko.unwrap

        //binding's init function
        this.init = function (element, valueAccessor, allBindings, data, context) {
            var existingSelect, existingChange,
                options = unwrap(valueAccessor()),
                config = {},
                filter = typeof options.filter === "function" ? options.filter : self.defaultFilter;

            //extend with global options
            ko.utils.extend(config, self.options);
            //override with options passed in binding
            ko.utils.extend(config, options.options);

            //get source from a function (can be remote call)
            if (typeof options.source === "function" && !ko.isObservable(options.source)) {
                config.source = function (request, response) {
                    //provide a wrapper to the normal response callback
                    var callback = function (data) {
                        self.processOptions(valueAccessor, null, data, request, response);
                    };

                    //call the provided function for retrieving data
                    options.source.call(context.$data, request.term, callback);
                };
            }
            else {
                //process local data
                config.source = self.processOptions.bind(self, valueAccessor, filter, options.source);
            }

            //save any passed in select/change calls
            existingSelect = typeof config.select === "function" && config.select;
            existingChange = typeof config.change === "function" && config.change;

            //handle updating the actual value
            config.select = function (event, ui) {
                if (ui.item && ui.item.actual) {
                    options.value(ui.item.actual);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        console.log("writeable")
                        options.dataValue(ui.item.data);
                    }
                }

                if (existingSelect) {
                    existingSelect.apply(this, arguments);
                }
                $(this).select();
                //modelGiaoDich.selectSearchHH();
                selecteditemHangHoa(ui.item.data);
            };

            //user made a change without selecting a value from the list
            config.change = function (event, ui) {
                if (!ui.item || !ui.item.actual) {
                    options.value(event.target && event.target.value);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(null);
                    }
                }

                if (existingChange) {
                    existingChange.apply(this, arguments);
                }
            };

            //initialize the widget
            var widget = $(element).autocomplete(config).data("ui-autocomplete");

            //render a template for the items
            if (options.template) {
                widget._renderItem = self.renderItem.bind(self, options.template, context);
            }

            //destroy the widget if KO removes the element
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                if (widget && typeof widget.destroy === "function") {
                    widget.destroy();
                    widget = null;
                }
            });
        };

        //the binding's update function. keep value in sync with model
        this.update = function (element, valueAccessor) {
            var propNames, sources,
                options = unwrap(valueAccessor()),
                value = unwrap(options && options.value);

            if (!value && value !== 0) {
                value = "";
            }

            // find the appropriate value for the input
            sources = unwrap(options.source);
            propNames = self.getPropertyNames(valueAccessor);

            // if there is local data, then try to determine the appropriate value for the input
            if ($.isArray(sources) && propNames.value) {
                value = ko.utils.arrayFirst(sources, function (opt) {
                    return opt[propNames.value] == value;
                }
                ) || value;
            }

            if (propNames.input && value && typeof value === "object") {
                element.value = value[propNames.input];
            }
            else {
                element.value = value;
            }
        };

        //if dealing with local data, the default filtering function
        this.defaultFilter = function (item, term) {
            term = term && term.toLowerCase();
            return (item || item === 0) && ko.toJSON(item).toLowerCase().indexOf(term) > -1;
        };
        var _IDchinhanh = $('#hd_IDdDonVi').val(); // lấy ID chi nhánh
        var timer = null;
        this.processOptions = function (valueAccessor, filter, data, request, response) {
            clearTimeout(timer);
            var propname = this.getPropertyNames(valueAccessor);
            timer = setTimeout(function () {
                $.ajax({
                    type: "GET",
                    url: "/api/DanhMuc/DM_HangHoaAPI/" + "SearchHangHoaByText?id_donvi=" + _IDchinhanh + "&txtSearch=" + request.term,
                    dataType: 'json',
                    contentType: 'application/json',
                    success: function (result) {
                        response(result);
                    },
                    error: function (error) {
                    }
                })
            }, 150);
            //console.log(1);
        };

        this.select = function (event, ui) {
            console.log("click1");
            $(this).val(ui.item.value).change();
        }

        //if specified, use a template to render an item
        this.renderItem = function (templateName, context, ul, item) {
            var $li = $("<li></li>").appendTo(ul),
                itemContext = context.createChildContext(item.data);

            //apply the template binding
            ko.applyBindingsToNode($li[0], { template: templateName }, itemContext);

            //clean up
            $li.one("remove", ko.cleanNode.bind(ko, $li[0]));

            return $li;
        };

        //retrieve the property names to use for the label, input, and value
        this.getPropertyNames = function (valueAccessor) {
            var options = ko.toJS(valueAccessor());

            return {
                label: options.labelProp || options.valueProp,
                input: options.inputProp || options.labelProp || options.valueProp,
                value: options.valueProp
            };
        };

        //default global options passed into autocomplete widget
        //this.options = {
        //    autoFocus: true,
        //    delay: 50,
        //};
    };
    ko.bindingHandlers.JqAutoHHNH = new JqAutoHHNH();

    var JqAutoHHTHN = function () {
        var self = this,
            unwrap = ko.utils.unwrapObservable; //support older KO versions that did not have ko.unwrap

        //binding's init function
        this.init = function (element, valueAccessor, allBindings, data, context) {
            var existingSelect, existingChange,
                options = unwrap(valueAccessor()),
                config = {},
                filter = typeof options.filter === "function" ? options.filter : self.defaultFilter;

            //extend with global options
            ko.utils.extend(config, self.options);
            //override with options passed in binding
            ko.utils.extend(config, options.options);

            //get source from a function (can be remote call)
            if (typeof options.source === "function" && !ko.isObservable(options.source)) {
                config.source = function (request, response) {
                    //provide a wrapper to the normal response callback
                    var callback = function (data) {
                        self.processOptions(valueAccessor, null, data, request, response);
                    };

                    //call the provided function for retrieving data
                    options.source.call(context.$data, request.term, callback);
                };
            }
            else {
                //process local data
                config.source = self.processOptions.bind(self, valueAccessor, filter, options.source);
            }

            //save any passed in select/change calls
            existingSelect = typeof config.select === "function" && config.select;
            existingChange = typeof config.change === "function" && config.change;

            //handle updating the actual value
            config.select = function (event, ui) {
                if (ui.item && ui.item.actual) {
                    options.value(ui.item.actual);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        console.log("writeable")
                        options.dataValue(ui.item.data);
                    }
                }

                if (existingSelect) {
                    existingSelect.apply(this, arguments);
                }
                $(this).select();
                //modelGiaoDich.selectSearchHH();
                selecteditemHangHoaTHN(ui.item.data);
            };

            //user made a change without selecting a value from the list
            config.change = function (event, ui) {
                if (!ui.item || !ui.item.actual) {
                    options.value(event.target && event.target.value);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(null);
                    }
                }

                if (existingChange) {
                    existingChange.apply(this, arguments);
                }
            };

            //initialize the widget
            var widget = $(element).autocomplete(config).data("ui-autocomplete");

            //render a template for the items
            if (options.template) {
                widget._renderItem = self.renderItem.bind(self, options.template, context);
            }

            //destroy the widget if KO removes the element
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                if (widget && typeof widget.destroy === "function") {
                    widget.destroy();
                    widget = null;
                }
            });
        };

        //the binding's update function. keep value in sync with model
        this.update = function (element, valueAccessor) {
            var propNames, sources,
                options = unwrap(valueAccessor()),
                value = unwrap(options && options.value);

            if (!value && value !== 0) {
                value = "";
            }

            // find the appropriate value for the input
            sources = unwrap(options.source);
            propNames = self.getPropertyNames(valueAccessor);

            // if there is local data, then try to determine the appropriate value for the input
            if ($.isArray(sources) && propNames.value) {
                value = ko.utils.arrayFirst(sources, function (opt) {
                    return opt[propNames.value] == value;
                }
                ) || value;
            }

            if (propNames.input && value && typeof value === "object") {
                element.value = value[propNames.input];
            }
            else {
                element.value = value;
            }
        };

        //if dealing with local data, the default filtering function
        this.defaultFilter = function (item, term) {
            term = term && term.toLowerCase();
            return (item || item === 0) && ko.toJSON(item).toLowerCase().indexOf(term) > -1;
        };
        var _IDchinhanh = $('#hd_IDdDonVi').val(); // lấy ID chi nhánh
        var timer = null;
        this.processOptions = function (valueAccessor, filter, data, request, response) {
            clearTimeout(timer);
            var propname = this.getPropertyNames(valueAccessor);
            timer = setTimeout(function () {
                $.ajax({
                    type: "GET",
                    url: "/api/DanhMuc/DM_HangHoaAPI/" + "SearchHangHoaByText?id_donvi=" + _IDchinhanh + "&txtSearch=" + request.term,
                    dataType: 'json',
                    contentType: 'application/json',
                    success: function (result) {
                        response(result);
                    },
                    error: function (error) {
                    }
                })
            }, 150);
            //console.log(1);
        };

        this.select = function (event, ui) {
            console.log("click1");
            $(this).val(ui.item.value).change();
        }

        //if specified, use a template to render an item
        this.renderItem = function (templateName, context, ul, item) {
            var $li = $("<li></li>").appendTo(ul),
                itemContext = context.createChildContext(item.data);

            //apply the template binding
            ko.applyBindingsToNode($li[0], { template: templateName }, itemContext);

            //clean up
            $li.one("remove", ko.cleanNode.bind(ko, $li[0]));

            return $li;
        };

        //retrieve the property names to use for the label, input, and value
        this.getPropertyNames = function (valueAccessor) {
            var options = ko.toJS(valueAccessor());

            return {
                label: options.labelProp || options.valueProp,
                input: options.inputProp || options.labelProp || options.valueProp,
                value: options.valueProp
            };
        };

        //default global options passed into autocomplete widget
        //this.options = {
        //    autoFocus: true,
        //    delay: 50,
        //};
    };
    ko.bindingHandlers.JqAutoHHTHN = new JqAutoHHTHN();

    //select hàng hóa Chuyển hàng
    var JqAutoHHChuyenH = function () {
        var self = this,
            unwrap = ko.utils.unwrapObservable; //support older KO versions that did not have ko.unwrap

        //binding's init function
        this.init = function (element, valueAccessor, allBindings, data, context) {
            var existingSelect, existingChange,
                options = unwrap(valueAccessor()),
                config = {},
                filter = typeof options.filter === "function" ? options.filter : self.defaultFilter;

            //extend with global options
            ko.utils.extend(config, self.options);
            //override with options passed in binding
            ko.utils.extend(config, options.options);

            //get source from a function (can be remote call)
            if (typeof options.source === "function" && !ko.isObservable(options.source)) {
                config.source = function (request, response) {
                    //provide a wrapper to the normal response callback
                    var callback = function (data) {
                        self.processOptions(valueAccessor, null, data, request, response);
                    };

                    //call the provided function for retrieving data
                    options.source.call(context.$data, request.term, callback);
                };
            }
            else {
                //process local data
                config.source = self.processOptions.bind(self, valueAccessor, filter, options.source);
            }

            //save any passed in select/change calls
            existingSelect = typeof config.select === "function" && config.select;
            existingChange = typeof config.change === "function" && config.change;

            //handle updating the actual value
            config.select = function (event, ui) {
                if (ui.item && ui.item.actual) {
                    options.value(ui.item.actual);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        console.log("writeable")
                        options.dataValue(ui.item.data);
                    }
                }

                if (existingSelect) {
                    existingSelect.apply(this, arguments);
                }
                $(this).select();
                selectHangHoaCHLo(ui.item.data);
            };

            //user made a change without selecting a value from the list
            config.change = function (event, ui) {
                if (!ui.item || !ui.item.actual) {
                    options.value(event.target && event.target.value);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(null);
                    }
                }

                if (existingChange) {
                    existingChange.apply(this, arguments);
                }
            };

            //initialize the widget
            var widget = $(element).autocomplete(config).data("ui-autocomplete");

            //render a template for the items
            if (options.template) {
                widget._renderItem = self.renderItem.bind(self, options.template, context);
            }

            //destroy the widget if KO removes the element
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                if (widget && typeof widget.destroy === "function") {
                    widget.destroy();
                    widget = null;
                }
            });
        };

        //the binding's update function. keep value in sync with model
        this.update = function (element, valueAccessor) {
            var propNames, sources,
                options = unwrap(valueAccessor()),
                value = unwrap(options && options.value);

            if (!value && value !== 0) {
                value = "";
            }

            // find the appropriate value for the input
            sources = unwrap(options.source);
            propNames = self.getPropertyNames(valueAccessor);

            // if there is local data, then try to determine the appropriate value for the input
            if ($.isArray(sources) && propNames.value) {
                value = ko.utils.arrayFirst(sources, function (opt) {
                    return opt[propNames.value] == value;
                }
                ) || value;
            }

            if (propNames.input && value && typeof value === "object") {
                element.value = value[propNames.input];
            }
            else {
                element.value = value;
            }
        };

        //if dealing with local data, the default filtering function
        this.defaultFilter = function (item, term) {
            term = term && term.toLowerCase();
            return (item || item === 0) && ko.toJSON(item).toLowerCase().indexOf(term) > -1;
        };
        var _IDchinhanh = $('#hd_IDdDonVi').val(); // lấy ID chi nhánh
        var timer = null;
        this.processOptions = function (valueAccessor, filter, data, request, response) {
            clearTimeout(timer);
            var propname = this.getPropertyNames(valueAccessor);
            timer = setTimeout(function () {
                $.ajax({
                    type: "GET",
                    url: "/api/DanhMuc/DM_HangHoaAPI/" + "SearchHangHoaByText?id_donvi=" + _IDchinhanh + "&txtSearch=" + request.term,
                    dataType: 'json',
                    contentType: 'application/json',
                    success: function (result) {
                        response(result);
                    },
                    error: function (error) {
                    }
                })
            }, 150);
        };

        this.select = function (event, ui) {
            console.log("click1");
            $(this).val(ui.item.value).change();
        }

        //if specified, use a template to render an item
        this.renderItem = function (templateName, context, ul, item) {
            var $li = $("<li></li>").appendTo(ul),
                itemContext = context.createChildContext(item.data);

            //apply the template binding
            ko.applyBindingsToNode($li[0], { template: templateName }, itemContext);

            //clean up
            $li.one("remove", ko.cleanNode.bind(ko, $li[0]));

            return $li;
        };

        //retrieve the property names to use for the label, input, and value
        this.getPropertyNames = function (valueAccessor) {
            var options = ko.toJS(valueAccessor());

            return {
                label: options.labelProp || options.valueProp,
                input: options.inputProp || options.labelProp || options.valueProp,
                value: options.valueProp
            };
        };

        //default global options passed into autocomplete widget
        //this.options = {
        //    autoFocus: true,
        //    delay: 50,
        //};
    };
    ko.bindingHandlers.JqAutoHHChuyenH = new JqAutoHHChuyenH();

    //Select Hàng hóa kiểm kho
    var JqAutoHHKiemK = function () {
        var self = this,
            unwrap = ko.utils.unwrapObservable; //support older KO versions that did not have ko.unwrap

        //binding's init function
        this.init = function (element, valueAccessor, allBindings, data, context) {
            var existingSelect, existingChange,
                options = unwrap(valueAccessor()),
                config = {},
                filter = typeof options.filter === "function" ? options.filter : self.defaultFilter;

            //extend with global options
            ko.utils.extend(config, self.options);
            //override with options passed in binding
            ko.utils.extend(config, options.options);

            //get source from a function (can be remote call)
            if (typeof options.source === "function" && !ko.isObservable(options.source)) {
                config.source = function (request, response) {
                    //provide a wrapper to the normal response callback
                    var callback = function (data) {
                        self.processOptions(valueAccessor, null, data, request, response);
                    };

                    //call the provided function for retrieving data
                    options.source.call(context.$data, request.term, callback);
                };
            }
            else {
                //process local data
                config.source = self.processOptions.bind(self, valueAccessor, filter, options.source);
            }

            //save any passed in select/change calls
            existingSelect = typeof config.select === "function" && config.select;
            existingChange = typeof config.change === "function" && config.change;

            //handle updating the actual value
            config.select = function (event, ui) {
                if (ui.item && ui.item.actual) {
                    options.value(ui.item.actual);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        console.log("writeable")
                        options.dataValue(ui.item.data);
                    }
                }

                if (existingSelect) {
                    existingSelect.apply(this, arguments);
                }
                $(this).select();
                itemSelectedHHKK(ui.item.data);
            };

            //user made a change without selecting a value from the list
            config.change = function (event, ui) {
                if (!ui.item || !ui.item.actual) {
                    options.value(event.target && event.target.value);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(null);
                    }
                }

                if (existingChange) {
                    existingChange.apply(this, arguments);
                }
            };

            //initialize the widget
            var widget = $(element).autocomplete(config).data("ui-autocomplete");

            //render a template for the items
            if (options.template) {
                widget._renderItem = self.renderItem.bind(self, options.template, context);
            }

            //destroy the widget if KO removes the element
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                if (widget && typeof widget.destroy === "function") {
                    widget.destroy();
                    widget = null;
                }
            });
        };

        //the binding's update function. keep value in sync with model
        this.update = function (element, valueAccessor) {
            var propNames, sources,
                options = unwrap(valueAccessor()),
                value = unwrap(options && options.value);

            if (!value && value !== 0) {
                value = "";
            }

            // find the appropriate value for the input
            sources = unwrap(options.source);
            propNames = self.getPropertyNames(valueAccessor);

            // if there is local data, then try to determine the appropriate value for the input
            if ($.isArray(sources) && propNames.value) {
                value = ko.utils.arrayFirst(sources, function (opt) {
                    return opt[propNames.value] == value;
                }
                ) || value;
            }

            if (propNames.input && value && typeof value === "object") {
                element.value = value[propNames.input];
            }
            else {
                element.value = value;
            }
        };

        //if dealing with local data, the default filtering function
        this.defaultFilter = function (item, term) {
            term = term && term.toLowerCase();
            return (item || item === 0) && ko.toJSON(item).toLowerCase().indexOf(term) > -1;
        };
        var _IDchinhanh = $('#hd_IDdDonVi').val(); // lấy ID chi nhánh
        var timer = null;
        this.processOptions = function (valueAccessor, filter, data, request, response) {
            clearTimeout(timer);
            var propname = this.getPropertyNames(valueAccessor);
            var txt = locdau(request.term);
            console.log(2, txt);
            timer = setTimeout(function () {
                $.ajax({
                    type: "GET",
                    url: "/api/DanhMuc/DM_HangHoaAPI/" + "SearchHangHoaByText?id_donvi=" + _IDchinhanh + "&txtSearch=" + txt,
                    dataType: 'json',
                    contentType: 'application/json',
                    success: function (result) {
                        response(result);
                    },
                    error: function (error) {
                    }
                })
            }, 150);
        };

        this.select = function (event, ui) {
            console.log("click1");
            $(this).val(ui.item.value).change();
        }

        //if specified, use a template to render an item
        this.renderItem = function (templateName, context, ul, item) {
            var $li = $("<li></li>").appendTo(ul),
                itemContext = context.createChildContext(item.data);

            //apply the template binding
            ko.applyBindingsToNode($li[0], { template: templateName }, itemContext);

            //clean up
            $li.one("remove", ko.cleanNode.bind(ko, $li[0]));

            return $li;
        };

        //retrieve the property names to use for the label, input, and value
        this.getPropertyNames = function (valueAccessor) {
            var options = ko.toJS(valueAccessor());

            return {
                label: options.labelProp || options.valueProp,
                input: options.inputProp || options.labelProp || options.valueProp,
                value: options.valueProp
            };
        };

        //default global options passed into autocomplete widget
        //this.options = {
        //    autoFocus: true,
        //    delay: 50,
        //};
    };
    ko.bindingHandlers.JqAutoHHKiemK = new JqAutoHHKiemK();

    //Select hàng hóa chương trình giá
    var JqAutoHHCTG = function () {
        var self = this,
            unwrap = ko.utils.unwrapObservable; //support older KO versions that did not have ko.unwrap

        //binding's init function
        this.init = function (element, valueAccessor, allBindings, data, context) {
            var existingSelect, existingChange,
                options = unwrap(valueAccessor()),
                config = {},
                filter = typeof options.filter === "function" ? options.filter : self.defaultFilter;

            //extend with global options
            ko.utils.extend(config, self.options);
            //override with options passed in binding
            ko.utils.extend(config, options.options);

            //get source from a function (can be remote call)
            if (typeof options.source === "function" && !ko.isObservable(options.source)) {
                config.source = function (request, response) {
                    //provide a wrapper to the normal response callback
                    var callback = function (data) {
                        self.processOptions(valueAccessor, null, data, request, response);
                    };

                    //call the provided function for retrieving data
                    options.source.call(context.$data, request.term, callback);
                };
            }
            else {
                //process local data
                config.source = self.processOptions.bind(self, valueAccessor, filter, options.source);
            }

            //save any passed in select/change calls
            existingSelect = typeof config.select === "function" && config.select;
            existingChange = typeof config.change === "function" && config.change;

            //handle updating the actual value
            config.select = function (event, ui) {
                if (ui.item && ui.item.actual) {
                    options.value(ui.item.actual);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        console.log("writeable")
                        options.dataValue(ui.item.data);
                    }
                }

                if (existingSelect) {
                    existingSelect.apply(this, arguments);
                }
                $(this).select();
            };

            //user made a change without selecting a value from the list
            config.change = function (event, ui) {
                if (!ui.item || !ui.item.actual) {
                    options.value(event.target && event.target.value);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(null);
                    }
                }

                if (existingChange) {
                    existingChange.apply(this, arguments);
                }
            };

            //initialize the widget
            var widget = $(element).autocomplete(config).data("ui-autocomplete");

            //render a template for the items
            if (options.template) {
                widget._renderItem = self.renderItem.bind(self, options.template, context);
            }

            //destroy the widget if KO removes the element
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                if (widget && typeof widget.destroy === "function") {
                    widget.destroy();
                    widget = null;
                }
            });
        };

        //the binding's update function. keep value in sync with model
        this.update = function (element, valueAccessor) {
            var propNames, sources,
                options = unwrap(valueAccessor()),
                value = unwrap(options && options.value);

            if (!value && value !== 0) {
                value = "";
            }

            // find the appropriate value for the input
            sources = unwrap(options.source);
            propNames = self.getPropertyNames(valueAccessor);

            // if there is local data, then try to determine the appropriate value for the input
            if ($.isArray(sources) && propNames.value) {
                value = ko.utils.arrayFirst(sources, function (opt) {
                    return opt[propNames.value] == value;
                }
                ) || value;
            }

            if (propNames.input && value && typeof value === "object") {
                element.value = value[propNames.input];
            }
            else {
                element.value = value;
            }
        };

        //if dealing with local data, the default filtering function
        this.defaultFilter = function (item, term) {
            term = term && term.toLowerCase();
            return (item || item === 0) && ko.toJSON(item).toLowerCase().indexOf(term) > -1;
        };
        var _IDchinhanh = $('#hd_IDdDonVi').val(); // lấy ID chi nhánh
        var timer = null;
        this.processOptions = function (valueAccessor, filter, data, request, response) {
            clearTimeout(timer);
            var propname = this.getPropertyNames(valueAccessor);
            timer = setTimeout(function () {
                $.ajax({
                    type: "GET",
                    url: "/api/DanhMuc/DM_HangHoaAPI/" + "SearchHangHoaByTextCTG?id_donvi=" + _IDchinhanh + "&txtSearch=" + request.term,
                    dataType: 'json',
                    contentType: 'application/json',
                    success: function (result) {
                        response(result);
                    },
                    error: function (error) {
                    }
                })
            }, 150);
        };

        this.select = function (event, ui) {
            console.log("click1");
            $(this).val(ui.item.value).change();
        }

        //if specified, use a template to render an item
        this.renderItem = function (templateName, context, ul, item) {
            var $li = $("<li></li>").appendTo(ul),
                itemContext = context.createChildContext(item.data);

            //apply the template binding
            ko.applyBindingsToNode($li[0], { template: templateName }, itemContext);

            //clean up
            $li.one("remove", ko.cleanNode.bind(ko, $li[0]));

            return $li;
        };

        //retrieve the property names to use for the label, input, and value
        this.getPropertyNames = function (valueAccessor) {
            var options = ko.toJS(valueAccessor());

            return {
                label: options.labelProp || options.valueProp,
                input: options.inputProp || options.labelProp || options.valueProp,
                value: options.valueProp
            };
        };

        //default global options passed into autocomplete widget
        this.options = {
            autoFocus: true,
            delay: 50,
        };
    };
    ko.bindingHandlers.JqAutoHHCTG = new JqAutoHHCTG();

    //select hàng hóa thành phần ở DM_HangHoa
    var JqAutoHHThanhPhan = function () {
        var self = this,
            unwrap = ko.utils.unwrapObservable; //support older KO versions that did not have ko.unwrap

        //binding's init function
        this.init = function (element, valueAccessor, allBindings, data, context) {
            var existingSelect, existingChange,
                options = unwrap(valueAccessor()),
                config = {},
                filter = typeof options.filter === "function" ? options.filter : self.defaultFilter;

            //extend with global options
            ko.utils.extend(config, self.options);
            //override with options passed in binding
            ko.utils.extend(config, options.options);

            //get source from a function (can be remote call)
            if (typeof options.source === "function" && !ko.isObservable(options.source)) {
                config.source = function (request, response) {
                    //provide a wrapper to the normal response callback
                    var callback = function (data) {
                        self.processOptions(valueAccessor, null, data, request, response);
                    };

                    //call the provided function for retrieving data
                    options.source.call(context.$data, request.term, callback);
                };
            }
            else {
                //process local data
                config.source = self.processOptions.bind(self, valueAccessor, filter, options.source);
            }

            //save any passed in select/change calls
            existingSelect = typeof config.select === "function" && config.select;
            existingChange = typeof config.change === "function" && config.change;

            //handle updating the actual value
            config.select = function (event, ui) {
                if (ui.item && ui.item.actual) {
                    options.value(ui.item.actual);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        console.log("writeable")
                        options.dataValue(ui.item.data);
                    }
                }

                if (existingSelect) {
                    existingSelect.apply(this, arguments);
                }
                $(this).select();
            };

            //user made a change without selecting a value from the list
            config.change = function (event, ui) {
                if (!ui.item || !ui.item.actual) {
                    options.value(event.target && event.target.value);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(null);
                    }
                }

                if (existingChange) {
                    existingChange.apply(this, arguments);
                }
            };

            //initialize the widget
            var widget = $(element).autocomplete(config).data("ui-autocomplete");

            //render a template for the items
            if (options.template) {
                widget._renderItem = self.renderItem.bind(self, options.template, context);
            }

            //destroy the widget if KO removes the element
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                if (widget && typeof widget.destroy === "function") {
                    widget.destroy();
                    widget = null;
                }
            });
        };

        //the binding's update function. keep value in sync with model
        this.update = function (element, valueAccessor) {
            var propNames, sources,
                options = unwrap(valueAccessor()),
                value = unwrap(options && options.value);

            if (!value && value !== 0) {
                value = "";
            }

            // find the appropriate value for the input
            sources = unwrap(options.source);
            propNames = self.getPropertyNames(valueAccessor);

            // if there is local data, then try to determine the appropriate value for the input
            if ($.isArray(sources) && propNames.value) {
                value = ko.utils.arrayFirst(sources, function (opt) {
                    return opt[propNames.value] == value;
                }
                ) || value;
            }

            if (propNames.input && value && typeof value === "object") {
                element.value = value[propNames.input];
            }
            else {
                element.value = value;
            }
        };

        //if dealing with local data, the default filtering function
        this.defaultFilter = function (item, term) {
            term = term && term.toLowerCase();
            return (item || item === 0) && ko.toJSON(item).toLowerCase().indexOf(term) > -1;
        };
        var _IDchinhanh = $('#hd_IDdDonVi').val(); // lấy ID chi nhánh
        var timer = null;
        this.processOptions = function (valueAccessor, filter, data, request, response) {
            clearTimeout(timer);
            var propname = this.getPropertyNames(valueAccessor);
            timer = setTimeout(function () {
                $.ajax({
                    type: "GET",
                    url: "/api/DanhMuc/DM_HangHoaAPI/" + "SearchHangHoaByTextTP?id_donvi=" + _IDchinhanh + "&txtSearch=" + request.term,
                    dataType: 'json',
                    contentType: 'application/json',
                    success: function (result) {
                        response(result);
                    },
                    error: function (error) {
                    }
                })
            }, 150);
        };

        this.select = function (event, ui) {
            console.log("click1");
            $(this).val(ui.item.value).change();
        }

        //if specified, use a template to render an item
        this.renderItem = function (templateName, context, ul, item) {
            var $li = $("<li></li>").appendTo(ul),
                itemContext = context.createChildContext(item.data);

            //apply the template binding
            ko.applyBindingsToNode($li[0], { template: templateName }, itemContext);

            //clean up
            $li.one("remove", ko.cleanNode.bind(ko, $li[0]));

            return $li;
        };

        //retrieve the property names to use for the label, input, and value
        this.getPropertyNames = function (valueAccessor) {
            var options = ko.toJS(valueAccessor());

            return {
                label: options.labelProp || options.valueProp,
                input: options.inputProp || options.labelProp || options.valueProp,
                value: options.valueProp
            };
        };

        //default global options passed into autocomplete widget
        this.options = {
            autoFocus: true,
            delay: 50,
        };
    };
    ko.bindingHandlers.JqAutoHHThanhPhan = new JqAutoHHThanhPhan();


    var JqAutoSoQuyDT = function () {
        var self = this,
            unwrap = ko.utils.unwrapObservable; //support older KO versions that did not have ko.unwrap

        //binding's init function
        this.init = function (element, valueAccessor, allBindings, data, context) {
            var existingSelect, existingChange,
                options = unwrap(valueAccessor()),
                config = {},
                filter = typeof options.filter === "function" ? options.filter : self.defaultFilter;

            //extend with global options
            ko.utils.extend(config, self.options);
            //override with options passed in binding
            ko.utils.extend(config, options.options);

            //get source from a function (can be remote call)
            if (typeof options.source === "function" && !ko.isObservable(options.source)) {
                config.source = function (request, response) {
                    //provide a wrapper to the normal response callback
                    var callback = function (data) {
                        self.processOptions(valueAccessor, null, data, request, response);
                    };

                    //call the provided function for retrieving data
                    options.source.call(context.$data, request.term, callback);
                };
            }
            else {
                //process local data
                config.source = self.processOptions.bind(self, valueAccessor, filter, options.source);
            }

            //save any passed in select/change calls
            existingSelect = typeof config.select === "function" && config.select;
            existingChange = typeof config.change === "function" && config.change;

            //handle updating the actual value
            config.select = function (event, ui) {
                if (ui.item && ui.item.actual) {
                    options.value(ui.item.actual);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        console.log("writeable")
                        options.dataValue(ui.item.data);
                    }
                }

                if (existingSelect) {
                    existingSelect.apply(this, arguments);
                }
                $(this).select();
            };

            //user made a change without selecting a value from the list
            config.change = function (event, ui) {
                if (!ui.item || !ui.item.actual) {
                    options.value(event.target && event.target.value);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(null);
                    }
                }

                if (existingChange) {
                    existingChange.apply(this, arguments);
                }
            };

            //initialize the widget
            var widget = $(element).autocomplete(config).data("ui-autocomplete");

            //render a template for the items
            if (options.template) {
                widget._renderItem = self.renderItem.bind(self, options.template, context);
            }

            //destroy the widget if KO removes the element
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                if (widget && typeof widget.destroy === "function") {
                    widget.destroy();
                    widget = null;
                }
            });
        };

        //the binding's update function. keep value in sync with model
        this.update = function (element, valueAccessor) {
            var propNames, sources,
                options = unwrap(valueAccessor()),
                value = unwrap(options && options.value);

            if (!value && value !== 0) {
                value = "";
            }

            // find the appropriate value for the input
            sources = unwrap(options.source);
            propNames = self.getPropertyNames(valueAccessor);

            // if there is local data, then try to determine the appropriate value for the input
            if ($.isArray(sources) && propNames.value) {
                value = ko.utils.arrayFirst(sources, function (opt) {
                    return opt[propNames.value] == value;
                }
                ) || value;
            }

            if (propNames.input && value && typeof value === "object") {
                element.value = value[propNames.input];
            }
            else {
                element.value = value;
            }
        };

        //if dealing with local data, the default filtering function
        this.defaultFilter = function (item, term) {
            term = term && term.toLowerCase();
            return (item || item === 0) && ko.toJSON(item).toLowerCase().indexOf(term) > -1;
        };
        var timer = null;
        this.processOptions = function (valueAccessor, filter, data, request, response) {
            clearTimeout(timer);
            var propname = this.getPropertyNames(valueAccessor);
            timer = setTimeout(function () {
                $.ajax({
                    type: "GET",
                    url: "/api/DanhMuc/Quy_HoaDonAPI/" + "GetListDoiTuongByLoai?loaiDoiTuong=" + modelSoQuy.CheckLoaiDoiTuong()
                        + "&txtSearch=" + request.term + "&idDonVi=" + VHeader.IdDonVi,
                    dataType: 'json',
                    contentType: 'application/json',
                    success: function (result) {
                        response(result);
                    },
                    error: function (error) {
                    }
                })
            }, 150);
        };

        this.select = function (event, ui) {
            console.log("click1");
            $(this).val(ui.item.value).change();
        }

        //if specified, use a template to render an item
        this.renderItem = function (templateName, context, ul, item) {
            var $li = $("<li></li>").appendTo(ul),
                itemContext = context.createChildContext(item.data);

            //apply the template binding
            ko.applyBindingsToNode($li[0], { template: templateName }, itemContext);

            //clean up
            $li.one("remove", ko.cleanNode.bind(ko, $li[0]));

            return $li;
        };

        //retrieve the property names to use for the label, input, and value
        this.getPropertyNames = function (valueAccessor) {
            var options = ko.toJS(valueAccessor());

            return {
                label: options.labelProp || options.valueProp,
                input: options.inputProp || options.labelProp || options.valueProp,
                value: options.valueProp
            };
        };

        //default global options passed into autocomplete widget
        //this.options = {
        //    autoFocus: true,
        //    delay: 50,
        //};
    };
    ko.bindingHandlers.JqAutoSoQuyDT = new JqAutoSoQuyDT();

    var JqAutoDTCongViec = function () {
        var self = this,
            unwrap = ko.utils.unwrapObservable; //support older KO versions that did not have ko.unwrap

        //binding's init function
        this.init = function (element, valueAccessor, allBindings, data, context) {
            var existingSelect, existingChange,
                options = unwrap(valueAccessor()),
                config = {},
                filter = typeof options.filter === "function" ? options.filter : self.defaultFilter;

            //extend with global options
            ko.utils.extend(config, self.options);
            //override with options passed in binding
            ko.utils.extend(config, options.options);

            //get source from a function (can be remote call)
            if (typeof options.source === "function" && !ko.isObservable(options.source)) {
                config.source = function (request, response) {
                    //provide a wrapper to the normal response callback
                    var callback = function (data) {
                        self.processOptions(valueAccessor, null, data, request, response);
                    };

                    //call the provided function for retrieving data
                    options.source.call(context.$data, request.term, callback);
                };
            }
            else {
                //process local data
                config.source = self.processOptions.bind(self, valueAccessor, filter, options.source);
            }

            //save any passed in select/change calls
            existingSelect = typeof config.select === "function" && config.select;
            existingChange = typeof config.change === "function" && config.change;

            //handle updating the actual value
            config.select = function (event, ui) {
                if (ui.item && ui.item.actual) {
                    options.value(ui.item.actual);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        console.log("writeable")
                        options.dataValue(ui.item.data);
                    }
                }

                if (existingSelect) {
                    existingSelect.apply(this, arguments);
                }
                $(this).select();
            };

            //user made a change without selecting a value from the list
            config.change = function (event, ui) {
                if (!ui.item || !ui.item.actual) {
                    options.value(event.target && event.target.value);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(null);
                    }
                }

                if (existingChange) {
                    existingChange.apply(this, arguments);
                }
            };

            //initialize the widget
            var widget = $(element).autocomplete(config).data("ui-autocomplete");

            //render a template for the items
            if (options.template) {
                widget._renderItem = self.renderItem.bind(self, options.template, context);
            }

            //destroy the widget if KO removes the element
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                if (widget && typeof widget.destroy === "function") {
                    widget.destroy();
                    widget = null;
                }
            });
        };

        //the binding's update function. keep value in sync with model
        this.update = function (element, valueAccessor) {
            var propNames, sources,
                options = unwrap(valueAccessor()),
                value = unwrap(options && options.value);

            if (!value && value !== 0) {
                value = "";
            }

            // find the appropriate value for the input
            sources = unwrap(options.source);
            propNames = self.getPropertyNames(valueAccessor);

            // if there is local data, then try to determine the appropriate value for the input
            if ($.isArray(sources) && propNames.value) {
                value = ko.utils.arrayFirst(sources, function (opt) {
                    return opt[propNames.value] == value;
                }
                ) || value;
            }

            if (propNames.input && value && typeof value === "object") {
                element.value = value[propNames.input];
            }
            else {
                element.value = value;
            }
        };

        //if dealing with local data, the default filtering function
        this.defaultFilter = function (item, term) {
            term = term && term.toLowerCase();
            return (item || item === 0) && ko.toJSON(item).toLowerCase().indexOf(term) > -1;
        };
        var timer = null;
        this.processOptions = function (valueAccessor, filter, data, request, response) {
            clearTimeout(timer);
            var propname = this.getPropertyNames(valueAccessor);
            timer = setTimeout(function () {
                $.ajax({
                    type: "GET",
                    url: "/api/DanhMuc/Quy_HoaDonAPI/" + "GetListDoiTuongByLoai?loaiDoiTuong=" + modelCV.checkDoiTuong() + "&txtSearch="
                        + request.term + "&idDonVi=" + VHeader.IdDonVi,
                    dataType: 'json',
                    contentType: 'application/json',
                    success: function (result) {
                        response(result);
                    },
                    error: function (error) {
                    }
                })
            }, 150);
        };

        this.select = function (event, ui) {
            console.log("click1");
            $(this).val(ui.item.value).change();
        }

        //if specified, use a template to render an item
        this.renderItem = function (templateName, context, ul, item) {
            var $li = $("<li></li>").appendTo(ul),
                itemContext = context.createChildContext(item.data);

            //apply the template binding
            ko.applyBindingsToNode($li[0], { template: templateName }, itemContext);

            //clean up
            $li.one("remove", ko.cleanNode.bind(ko, $li[0]));

            return $li;
        };

        //retrieve the property names to use for the label, input, and value
        this.getPropertyNames = function (valueAccessor) {
            var options = ko.toJS(valueAccessor());

            return {
                label: options.labelProp || options.valueProp,
                input: options.inputProp || options.labelProp || options.valueProp,
                value: options.valueProp
            };
        };

        //default global options passed into autocomplete widget
        //this.options = {
        //    autoFocus: true,
        //    delay: 50,
        //};
    };
    ko.bindingHandlers.JqAutoDTCongViec = new JqAutoDTCongViec();

    var JqAutoSoQuyDTNhapHang = function () {
        var self = this,
            unwrap = ko.utils.unwrapObservable; //support older KO versions that did not have ko.unwrap

        //binding's init function
        this.init = function (element, valueAccessor, allBindings, data, context) {
            var existingSelect, existingChange,
                options = unwrap(valueAccessor()),
                config = {},
                filter = typeof options.filter === "function" ? options.filter : self.defaultFilter;

            //extend with global options
            ko.utils.extend(config, self.options);
            //override with options passed in binding
            ko.utils.extend(config, options.options);

            //get source from a function (can be remote call)
            if (typeof options.source === "function" && !ko.isObservable(options.source)) {
                config.source = function (request, response) {
                    //provide a wrapper to the normal response callback
                    var callback = function (data) {
                        self.processOptions(valueAccessor, null, data, request, response);
                    };

                    //call the provided function for retrieving data
                    options.source.call(context.$data, request.term, callback);
                };
            }
            else {
                //process local data
                config.source = self.processOptions.bind(self, valueAccessor, filter, options.source);
            }

            //save any passed in select/change calls
            existingSelect = typeof config.select === "function" && config.select;
            existingChange = typeof config.change === "function" && config.change;

            //handle updating the actual value
            config.select = function (event, ui) {
                if (ui.item && ui.item.actual) {
                    options.value(ui.item.actual);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        console.log("writeable")
                        options.dataValue(ui.item.data);
                    }
                }

                if (existingSelect) {
                    existingSelect.apply(this, arguments);
                }
                $(this).select();
            };

            //user made a change without selecting a value from the list
            config.change = function (event, ui) {
                if (!ui.item || !ui.item.actual) {
                    options.value(event.target && event.target.value);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(null);
                    }
                }

                if (existingChange) {
                    existingChange.apply(this, arguments);
                }
            };

            //initialize the widget
            var widget = $(element).autocomplete(config).data("ui-autocomplete");

            //render a template for the items
            if (options.template) {
                widget._renderItem = self.renderItem.bind(self, options.template, context);
            }

            //destroy the widget if KO removes the element
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                if (widget && typeof widget.destroy === "function") {
                    widget.destroy();
                    widget = null;
                }
            });
        };

        //the binding's update function. keep value in sync with model
        this.update = function (element, valueAccessor) {
            var propNames, sources,
                options = unwrap(valueAccessor()),
                value = unwrap(options && options.value);

            if (!value && value !== 0) {
                value = "";
            }

            // find the appropriate value for the input
            sources = unwrap(options.source);
            propNames = self.getPropertyNames(valueAccessor);

            // if there is local data, then try to determine the appropriate value for the input
            if ($.isArray(sources) && propNames.value) {
                value = ko.utils.arrayFirst(sources, function (opt) {
                    return opt[propNames.value] == value;
                }
                ) || value;
            }

            if (propNames.input && value && typeof value === "object") {
                element.value = value[propNames.input];
            }
            else {
                element.value = value;
            }
        };

        //if dealing with local data, the default filtering function
        this.defaultFilter = function (item, term) {
            term = term && term.toLowerCase();
            return (item || item === 0) && ko.toJSON(item).toLowerCase().indexOf(term) > -1;
        };
        var timer = null;
        this.processOptions = function (valueAccessor, filter, data, request, response) {
            clearTimeout(timer);
            var propname = this.getPropertyNames(valueAccessor);
            timer = setTimeout(function () {
                $.ajax({
                    type: "GET",
                    url: "/api/DanhMuc/Quy_HoaDonAPI/" + "GetListDoiTuongByLoai?loaiDoiTuong=" + 2 + "&txtSearch=" + request.term
                        + "&idDonVi=" + VHeader.IdDonVi,
                    dataType: 'json',
                    contentType: 'application/json',
                    success: function (result) {
                        response(result);
                    },
                    error: function (error) {
                    }
                })
            }, 150);
        };

        this.select = function (event, ui) {
            console.log("click1");
            $(this).val(ui.item.value).change();
        }

        //if specified, use a template to render an item
        this.renderItem = function (templateName, context, ul, item) {
            var $li = $("<li></li>").appendTo(ul),
                itemContext = context.createChildContext(item.data);

            //apply the template binding
            ko.applyBindingsToNode($li[0], { template: templateName }, itemContext);

            //clean up
            $li.one("remove", ko.cleanNode.bind(ko, $li[0]));

            return $li;
        };

        //retrieve the property names to use for the label, input, and value
        this.getPropertyNames = function (valueAccessor) {
            var options = ko.toJS(valueAccessor());

            return {
                label: options.labelProp || options.valueProp,
                input: options.inputProp || options.labelProp || options.valueProp,
                value: options.valueProp
            };
        };

        //default global options passed into autocomplete widget
        //this.options = {
        //    autoFocus: true,
        //    delay: 50,
        //};
    };
    ko.bindingHandlers.JqAutoSoQuyDTNhapHang = new JqAutoSoQuyDTNhapHang();

    var JqAutoSoQuyNV = function () {
        var self = this,
            unwrap = ko.utils.unwrapObservable; //support older KO versions that did not have ko.unwrap

        //binding's init function
        this.init = function (element, valueAccessor, allBindings, data, context) {
            var existingSelect, existingChange,
                options = unwrap(valueAccessor()),
                config = {},
                filter = typeof options.filter === "function" ? options.filter : self.defaultFilter;

            //extend with global options
            ko.utils.extend(config, self.options);
            //override with options passed in binding
            ko.utils.extend(config, options.options);

            //get source from a function (can be remote call)
            if (typeof options.source === "function" && !ko.isObservable(options.source)) {
                config.source = function (request, response) {
                    //provide a wrapper to the normal response callback
                    var callback = function (data) {
                        self.processOptions(valueAccessor, null, data, request, response);
                    };

                    //call the provided function for retrieving data
                    options.source.call(context.$data, request.term, callback);
                };
            }
            else {
                //process local data
                config.source = self.processOptions.bind(self, valueAccessor, filter, options.source);
            }

            //save any passed in select/change calls
            existingSelect = typeof config.select === "function" && config.select;
            existingChange = typeof config.change === "function" && config.change;

            //handle updating the actual value
            config.select = function (event, ui) {
                if (ui.item && ui.item.actual) {
                    options.value(ui.item.actual);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        console.log("writeable")
                        options.dataValue(ui.item.data);
                    }
                }

                if (existingSelect) {
                    existingSelect.apply(this, arguments);
                }
                $(this).select();
            };

            //user made a change without selecting a value from the list
            config.change = function (event, ui) {
                if (!ui.item || !ui.item.actual) {
                    options.value(event.target && event.target.value);

                    if (ko.isWriteableObservable(options.dataValue)) {
                        options.dataValue(null);
                    }
                }

                if (existingChange) {
                    existingChange.apply(this, arguments);
                }
            };

            //initialize the widget
            var widget = $(element).autocomplete(config).data("ui-autocomplete");

            //render a template for the items
            if (options.template) {
                widget._renderItem = self.renderItem.bind(self, options.template, context);
            }

            //destroy the widget if KO removes the element
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                if (widget && typeof widget.destroy === "function") {
                    widget.destroy();
                    widget = null;
                }
            });
        };

        //the binding's update function. keep value in sync with model
        this.update = function (element, valueAccessor) {
            var propNames, sources,
                options = unwrap(valueAccessor()),
                value = unwrap(options && options.value);

            if (!value && value !== 0) {
                value = "";
            }

            // find the appropriate value for the input
            sources = unwrap(options.source);
            propNames = self.getPropertyNames(valueAccessor);

            // if there is local data, then try to determine the appropriate value for the input
            if ($.isArray(sources) && propNames.value) {
                value = ko.utils.arrayFirst(sources, function (opt) {
                    return opt[propNames.value] == value;
                }
                ) || value;
            }

            if (propNames.input && value && typeof value === "object") {
                element.value = value[propNames.input];
            }
            else {
                element.value = value;
            }
        };

        //if dealing with local data, the default filtering function
        this.defaultFilter = function (item, term) {
            term = term && term.toLowerCase();
            return (item || item === 0) && ko.toJSON(item).toLowerCase().indexOf(term) > -1;
        };
        var timer = null;
        var _IDchinhanh = $('#hd_IDdDonVi').val();
        this.processOptions = function (valueAccessor, filter, data, request, response) {
            clearTimeout(timer);
            var propname = this.getPropertyNames(valueAccessor);
            timer = setTimeout(function () {
                $.ajax({
                    type: "GET",
                    url: "/api/DanhMuc/Quy_HoaDonAPI/" + "GetListNhanVienSoQuy?iddonvi=" + _IDchinhanh + "&txtSearch=" + request.term,
                    dataType: 'json',
                    contentType: 'application/json',
                    success: function (result) {
                        response(result);
                    },
                    error: function (error) {
                    }
                })
            }, 150);
        };

        this.select = function (event, ui) {
            console.log("click1");
            $(this).val(ui.item.value).change();
        }

        //if specified, use a template to render an item
        this.renderItem = function (templateName, context, ul, item) {
            var $li = $("<li></li>").appendTo(ul),
                itemContext = context.createChildContext(item.data);

            //apply the template binding
            ko.applyBindingsToNode($li[0], { template: templateName }, itemContext);

            //clean up
            $li.one("remove", ko.cleanNode.bind(ko, $li[0]));

            return $li;
        };

        //retrieve the property names to use for the label, input, and value
        this.getPropertyNames = function (valueAccessor) {
            var options = ko.toJS(valueAccessor());

            return {
                label: options.labelProp || options.valueProp,
                input: options.inputProp || options.labelProp || options.valueProp,
                value: options.valueProp
            };
        };

        //default global options passed into autocomplete widget
        //this.options = {
        //    autoFocus: true,
        //    delay: 50,
        //};
    };
    ko.bindingHandlers.JqAutoSoQuyNV = new JqAutoSoQuyNV();
});

